generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// ============================================
// UŻYTKOWNIK
// ============================================
model User {
  id            Int            @id @default(autoincrement())
  email         String         @unique
  passwordHash  String
  firstName     String
  lastName      String
  dateOfBirth   DateTime
  phone         String         // ← ZMIENIONE: usunięto ? (teraz obowiązkowe)
  emailVerified Boolean        @default(false)
  billingDay    Int?    // dzień miesiąca 1-28, null = nieustalony
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  
  subscriptions Subscription[]
  userTitles    UserTitle[]
  payments      Payment[]
  watchEvents   WatchEvent[]
  billingCycles BillingCycle[]

  @@map("users")
}


// ============================================
// PLATFORMY I PLANY
// ============================================
model Provider {
  code          String         @id
  name          String
  website       String?
  logoUrl       String?
  plans         Plan[]
  subscriptions Subscription[]

  @@map("providers")
}

model Plan {
  id             Int            @id @default(autoincrement())
  providerCode   String
  country        String         @default("PL")
  planName       String
  pricePLN       Float
  cycle          String         @default("monthly")
  screens        Int
  uhd            Boolean
  ads            Boolean
  lastVerifiedAt DateTime       @default(now())
  
  provider       Provider       @relation(fields: [providerCode], references: [code])
  subscriptions  Subscription[]
  pendingSubscriptions Subscription[] @relation("PendingPlan")

  @@unique([providerCode, planName])
  @@map("plans")
}

// ============================================
// SUBSKRYPCJE UŻYTKOWNIKA
// ============================================
model Subscription {
  id               Int       @id @default(autoincrement())
  userId           Int
  providerCode     String
  planId           Int
  pendingPlanId    Int?      // nowy plan czekający na wejście w życie
  priceOverridePLN Float?
  nextRenewalDate DateTime  // najbliższa data odnowienia (miesięczne i roczne)
  status           String    @default("active")
  // active | cancelled | pending_change | pending_cancellation
  activeUntil      DateTime? // data do kiedy działa przy pending_cancellation
  pendingChargePLN Float?    // dopłata proporcjonalna za upgrade, doliczana do najbliższego billingu
  cancelledAt      DateTime?
  createdAt        DateTime  @default(now())

  user             User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  provider         Provider  @relation(fields: [providerCode], references: [code])
  plan             Plan      @relation(fields: [planId], references: [id])
  pendingPlan      Plan?     @relation("PendingPlan", fields: [pendingPlanId], references: [id])
  billingItems     BillingCycleItem[]

  @@map("subscriptions")
}

// ============================================
// FILMY/SERIALE (CACHE Z TMDB)
// ============================================
model Title {
  id             Int            @id @default(autoincrement())
  tmdbId         Int            @unique
  imdbId         String?
  titlePL        String
  titleOriginal  String
  year           Int?
  runtime        Int?
  plot           String?
  posterUrl      String?
  genres         String         // JSON array jako string
  createdAt      DateTime       @default(now())
  
  availability   Availability[]
  userTitles     UserTitle[]

  @@map("titles")
}

model Availability {
  id           Int      @id @default(autoincrement())
  titleId      Int
  providerCode String
  offerType    String   // "subscription", "rent", "buy"
  pricePLN     Float?
  quality      String?  // "SD", "HD", "4K"
  link         String?
  region       String   @default("PL")
  lastSeenAt   DateTime @default(now())
  
  title        Title    @relation(fields: [titleId], references: [id], onDelete: Cascade)

  @@map("availability")
}

// ============================================
// ULUBIONE / OBEJRZANE
// ============================================
model UserTitle {
  userId    Int
  titleId   Int
  favorite  Boolean  @default(false)
  watched   Boolean  @default(false)
  rating    Int?     // 1-10
  updatedAt DateTime @default(now()) @updatedAt
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  title     Title    @relation(fields: [titleId], references: [id], onDelete: Cascade)

  @@id([userId, titleId])
  @@map("user_titles")
}


model Payment {
  id        String        @id @default(cuid())
  userId    Int
  period    String        // YYYY-MM
  amountPLN Float
  status    String        @default("SIMULATED_PAID")
  createdAt DateTime      @default(now())
  
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  items     PaymentItem[]

  @@map("payments")
}

model PaymentItem {
  id           Int     @id @default(autoincrement())
  paymentId    String
  providerCode String
  planName     String
  pricePLN     Float
  
  payment      Payment @relation(fields: [paymentId], references: [id], onDelete: Cascade)

  @@map("payment_items")
}

// ============================================
// HISTORIA OGLĄDANIA
// ============================================
model WatchEvent {
  id        Int      @id @default(autoincrement())
  userId    Int
  title     String
  minutes   Int
  watchedAt DateTime @default(now())
  period    String   // YYYY-MM
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("watch_events")
}

model BillingCycle {
  id          String             @id @default(cuid())
  userId      Int
  period      String             // "2026-03"
  billingDate DateTime           // konkretna data płatności np. 2026-03-10
  totalPLN    Float
  status      String             @default("pending") // pending, paid, overdue
  createdAt   DateTime           @default(now())

  user        User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  items       BillingCycleItem[]

  @@unique([userId, period])
  @@map("billing_cycles")
}

model BillingCycleItem {
  id             Int          @id @default(autoincrement())
  billingCycleId String
  subscriptionId Int
  providerCode   String
  planName       String
  pricePLN       Float
  periodFrom     DateTime
  periodTo       DateTime
  creditApplied  Float        @default(0)

  billingCycle   BillingCycle @relation(fields: [billingCycleId], references: [id], onDelete: Cascade)
  subscription   Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@map("billing_cycle_items")
}